# 指令格式与寻址方式

## 指令格式

Intel 8086/8088 基本指令格式:

    op dst, src  ; 由 "源" 至 "目的", 结果在目的操作数中

（分号 `;` 以后的内容为行注释）

指令可以有 2 个, 1 个或 0 个操作数:

- `op op2, op1`
- `op op1`
- `op`

指令编码由 1-7 个字节组成，为变长编码。编码要素: 

- 操作码字节
- 寻址方式字节
- 段超越字节
- 操作数

## 寻址方式

<!-- 与数据有关: 

- 立即寻址
- 寄存器寻址
- 直接寻址
- 寄存器间接寻址
- 寄存器相对寻址
- 基址变址寻址

与转移/调用指令有关:

- 段内直接寻址
- 段内间接寻址
- 段间直接寻址
- 段间间接寻址

与 IO 有关:

- 直接 I/O 端口寻址
- 寄存器 DX 间接寻址 -->

## 与数据有关的寻址方式 (6 种)

(目的, 源) 操作数可以来自:

- 寄存器: 8 个通用寄存器, 4 个段寄存器, 1 个标志寄存器
- 立即数: 指令本身给出的立即数 (常量)
- 内存单元: 直接寻址/间接寻址
- 定义操作数: 
  - `EQU`: 常量
  - `DB`: 字节
  - `DW`: 字
  - `DD`: 双字

寻址方式:

- 立即寻址: 指令操作数包含在指令中，为一个常量或常数
- 寄存器寻址: 指令操作数为 CPU 的寄存器
- 直接寻址: 操作数偏移地址 `EA` 在指令中给出，如**变量名**
- 寄存器间接寻址: 操作数地址 `EA` 位于**间指**寄存器 (`BX`, `BP`, `SI`, `DI`) 中
- 寄存器相对寻址: 操作数地址 `EA` 由间指寄存器 + 8 位或 16 位的常量组成
- 基址变址寻址: 操作数地址 `EA` 为一个基址寄存器和一个变址寄存器之和

掌握和理解寻址要点:

1. 寄存器的使用规则
2. 类型匹配
3. 数据通路
4. 操作的是"内容"还是"地址"(指针)

### 立即寻址

指令所需操作数直接包含在指令代码中，可以是一个**常量** (由 `EQU` 定义) 或者一个**常数**，成为**立即数**。

立即数可以是 8 位或 16 位，需要看与之对应的另一个操作数的类型（二者需要匹配）

    VALUE EQU 512       ; 定义一个常量, 名称为 VALUE, 值为 512
    MOV AL, 05H         ; AL = 05H
    MOV AL, 00000101b   ; AL = 05H, b 表示二进制
    MOV AX, 512         ; AX = 0200H (512 的十六进制)
    MOV AX, 512         ; AX = 0200H (VALUE 是常量，值是 512)

<font color="red">错误示例</font>:

    MOV AL, 100H        ; 100H 超出了 1 字节的范围
    MOV BL, VALUE       ; VALUE = 512, 超出了 1 字节的范围
    MOV AX, 10000H      ; 10000H 超出了 16 位 (一个字) 的范围

### 寄存器寻址

指令中所需的操作数是 CPU 的某个寄存器，取操作数完全在 CPU 内部进行，不需要访存。

- 对于 8 位操作数，寄存器可以是 `AH`, `AL`, `BH`, `BL`, `CH`, `CL`, `DH`, `DL` 中的一个。
- 对于 16 位操作数，寄存器可以是 `AX`, `BX`, `CX`, `DX`, `SP`, `BP`, `SI`, `DI` 及 `CS`, `DS`, `SS`, `ES` 的任何一个（没有 `IP`）

寄存器寻址方式示例:

    MOV AX, BX      ; 源操作数和目的操作数都是寄存器寻址
    MOV AX, 1234H   ; 目的操作数是寄存器寻址
    ADD X, AX       ; 目的操作数是寄存器寻址
    PUSH DS         ; 源操作数是寄存器寻址

<!-- ADD X, AX 这条指令, X 是什么? -->

当使用 `CS`, `DS`, `SS`, `ES` 段寄存器时，必须遵循数据通路要求。

操作数中的寄存器可能是隐含的寄存器（没有明确出现在指令的源或目的操作数中），例如:

    PUSHF           ; PSW (标志寄存器) 作为源操作数，是寄存器寻址方式
    STD             ; 设置 DF = 1, 目的操作数是寄存器寻址方式

### 直接寻址

操作数的偏移地址直接在指令中给出。例如:

    MOV AX, [2000H]     ; 源操作数 [2000H] 为直接寻址
    ; 相当于 AX = *(uint16_t*)(0x2000)

以上示例中源操作数 `[2000H]` 是直接寻址。（加 `[]` 表示其内部的 `2000H` 是地址，如不加则是立即寻址）

如没有段超越，通常以这种方式直接寻址去操作数都是相对数据段 `DS` 的。

如使用变量（符号）定义内存中的单元，在指令中直接使用符号也是直接寻址，虽然操作数中并未直接出现地址，但汇编语言程序经过汇编器后，汇编器计算出符号的偏移值并进行替换。例如:

    ; 以下两行为伪指令, 定义了两个变量
    x DW ?      ; 定义一个字变量(DW), ? 表示未指定初始值
    c DB 'A'    ; 定义一个字节变量, 初始值为 41H
    ; 以下指令为直接寻址
    MOV AX, x   ; 将变量 x 的字存入 AX 寄存器
    MOV AL, c   ; 将变量 c 的字节存入 AL 寄存器
    ; 以下指令也是直接寻址
    MOV AX, x+1 ; 将内存 x+1 单元的字存入 AX 寄存器

### 寄存器间接寻址

操作数的有效地址 EA 不位于指令中，而是位于**基址寄存器 `BX`, `BP`**或**变址寄存器 `SI`, `DI`**中（不能是其他寄存器）。因为地址值未在指令中直接指出，而是通过一个寄存器来指明，因此称为间接寻址。效果上，这个寄存器相当于一个地址指针。

例如下面指令的源操作数的寻址方式都是间接寻址:

    MOV AX, [BX]    ; 内存操作数的偏移地址位于 BX 中，在 DS 段内
    MOV BH, [BP]    ; 内存操作数的偏移地址位于 BP 中，在 SS 段内
    MOV CX, [SI]    ; 内存操作数的偏移地址位于 SI 中，在 DS 段内
    MOV DL, [DI]    ; 内存操作数的偏移地址位于 DI 中，在 DS 段内。

<font color="red">错误示例</font>:

    MOV AX, [DX]    ; DX 不能作为间接寻址寄存器
    MOV DL, [BL]    ; 只能用完整的 BX, 不能用 BL 作为间接寻址寄存器, 因为偏移值是 16 位

#### 隐含段规则

使用以上 4 个寄存器进行间接寻址时，如果未显式指定段寄存器，则 `BX`, `SI`, `DI` 是相对 `DS` 段的偏移地址，而 `BP` 是相对 `SS` 段的偏移地址。

上述四条指令分别与下面四条指令等价:

    MOV AX, DS:[BX]
    MOV BH, SS:[BP]
    MOV CX, DS:[SI]
    MOV DL, DS:[DI]

**注意**: 堆栈指针 `SP` <font color="red">不可以</font>用来间接寻址!

#### 段超越

如果寻址是不用寄存器默认隐含的段，而是显式地指定一个段寄存器，则称为**段超越**。例如:

    MOV AX, SS:[BX] ; BX 默认相对段 DS，此处指定用段 SS 代替默认的 DS
    MOV CS:[BP], DX ; 指定段 CS 代替 BP 寄存器默认的 SS, 该指令会修改代码段，有一定危险性

### 寄存器相对寻址

操作数的有效地址 EA 是一个基址寄存器或变址寄存器的内容和指令中指定的 8 位和 16 位位移量之和。

即: EA = 间址寄存器的值 + 8 位或 16 位常量

也就是在间接寻址的基础上增加了一个常量（间接寻址 + 相对寻址）。

可用来寻址的寄存器与隐含段规则同间接寻址, `BX`, `SI`, `DI` 寄存器寻址的默认段是数据段 `DS`, `BP` 寄存器寻址的默认段是堆栈段 `SS`。

寄存器相对寻址示例(以下指令中的源操作数):

    MOV AX, [SI+10H]    ; SI 的值加 10H 形成偏移地址, 在 DS 段内寻址

其中 `[SI+10H]` 也可以写成 `10H[SI]`，即上面的指令和下面的指令等价:

    MOV AX, 10H[SI]

与直接寻址一样，相对寻址的 16 位偏移量也可以是个符号名或变量名。因为符号名和变量名在段内的位置(偏移值)是固定的，所以作用等同于常量。

采用符号名进行相对寻址的示例:

    MOV AX, ARRAY[SI]   ; EA = SI 的值 + ARRAY 相对 DS 的偏移值
    MOV TABLE[DI], AL   ; EA = DI 的值 + TABLE 相对 DS 的偏移值
    MOV TABLE[DI+1], AL ; EA = DI 的值 + TABLE 的偏移值 + 1

### 基址变址寻址

操作数的有效地址 EA 等于一个基址寄存器和一个变址寄存器的内容之和。

显著特点: 两个寄存器均出现在指令中。

基址寄存器为 `BX` 或 `BP`, 变址寄存器为 `SI` 或 `DI`。如果基址寄存器为 `BX`, 则缺省段寄存器为 `DS`; 如果基址寄存器为 `BP`, 则缺省段寄存器为 `SS`。

示例:

    MOV AX, [BX][SI]    ; 源操作数 EA = BX + SI, 段为 DS
    MOV AX, [BX+SI]     ; 等同上一条指令
    MOV ES:[BX+SI], AL  ; 目的操作数 EA = BX + SI, 段为 ES (采用了段超越)
    MOV [BP+DI], AX     ; 目的操作数 EA = BP + DI, 段为 SS

可以将基址变址寻址方式理解为寄存器相对寻址方式加上一个变址寄存器。例如:

    MOV AX, [BX+SI+200] ; 源操作数的 EA = BX + SI + 200, 段为 DS
    MOV ARRAY[BP + SI], AX  ; 目的操作数 EA = BP + SI + ARRAY 的偏移量, 段为 SS

**注意**: 基址变址寻址方式的基址寄存器**只能为 `BX` 或 `BP`**, 变址寄存器**只能是 `SI` 或 `DI`**。

<font color="red">错误示例</font>:

    MOV [BX+CX], AX     ; CX 不能作为变址寄存器
    MOV [BX+BP], AX     ; BP 只能用作基址寄存器, 不能用于变址寄存器
    MOV [BX+DI], ARRAY  ; 如果 ARRAY 为变量, 则源和目的操作数都在内存中, 不合法

最后一条指令如果 ARRAY 是变量, 则源操作数是直接寻址, 源和目的操作数不能都在内存中（此部分详见**数据通路**），但 ARRAY 如果是立即数，则源操作数是立即寻址，没问题。

## 与转移地址有关的寻址方式

与转移地址有关的寻址方式主要运用于转移指令 `JMP` 和过程调用指令 `CALL`，寻址方式共有四种:

- 段内直接寻址
- 段内间接寻址
- 段间直接寻址
- 段间间接寻址

### 标号与过程名

标号示例:

    ...
    l1: MOV AX, ARRAY[SI]
    ...

上例中 `l1` 是一个标号，后面跟有一个冒号，一般位于一条指令的前面。标号的作用与变量名类似，确定了标号后的指令在代码段中的偏移地址。

过程名示例:

        ...
    p1  PROC near
        ...
        RET
    p1  ENDP

或

        ...
    p2  PROC far
        ...
        RET
    p2  ENDP

过程位于程序代码中，上述两个例子的 `p1` 和 `p2` 是过程名，确定了该过程第一条指令在代码段中的偏移值。其中 `p2` 还同时指出了它所处的 `CS` 段值（用 `far` 表示）

### 段内直接寻址

要转向（由 `JMP`, 条件转移，`CALL` 等）指令实际的有效地址是当前 `IP` 寄存器的内容和指令中指定的 8 位或 16 位位移量之和。

在定义了前面的标号 `l1` 或子程序名 `p1`, `p2` 后，段内直接寻址的示例:

    JMP l1  ; 转移至标号 l1 处
    CALL p1 ; 先保存 CALL 下一条指令的偏移地址至堆栈中，然后转移至 p1 处

与操作数的直接寻址方式不同的是，上述指令在汇编后，指令的机器码不会直接出现 `l1` 或 `p1` 的偏移地址，而是相对于当前 IP 的位移量，是一种相对寻址。

根据位移量是 8 位还是 16 位，可以加 `SHORT` 和 `NEAR PTR` 操作符, 如下例所示:

    JMP SHORT l1    ; l1 与当前 IP 的位移量是一个 8 位值
    JMP NEAR PTR l1 ; l1 与当前 IP 的位移量是一个 16 位值

对于**条件转移指令，只能是 8 位位移量**，省略 `SHORT` 操作符。

如果 JMP 指令省略了 `NEAR PTR` 或 `SHORT` 操作符，则使用 16 位位移量。使用 8 位位移量的转移称为短跳转。

### 段内间接寻址

转向的有效地址是一个**寄存器**或**存储单元**的内容。

- 寄存器: 可以是 `AX`, `BX`, `CX`, `DX`, `SI`, `SI`, `BP`, `SP` 中的任何一个。
- 存储单元: 位于数据段中，可以使用四种内存寻址方式中的任何一种。

在转移指令中使用寄存器间接寻址时，寄存器保存的是相对**代码段 `CS`**而不是数据段的偏移值。（与数据相关的寻址不同！）

示例: 用寄存器 `AX` 作为间接寻址寄存器

    MOV AX, OFFSET p1   ; 获取 p1 过程在代码段内的偏移值
    CALL AX

上例中 `AX` 也可以用 `BX`, `CX`, `DX`, `BP`, `SI`, `DI` 来代替, 且都是相对于代码段的。使用 `SP` 在语法上也允许，但逻辑上通常不这样使用。

注意段内间接寻址和数据寄存器间接寻址的差别:

    MOV AX, [BX]    ; 数据寄存器间接寻址
    JMP BX          ; 转移指令的段内间接寻址

数据寻址的寄存器间接方式中， `[BX]` 有方括号，相对于数据段寻址。

当间接寻址使用内存单元存放时, 要转移的偏移地址位于数据段的某个位置，而要转移至的位置则位于代码段中。

在下列指令中，转移地址同样使用的是段内间接转移:

    MOV AX, OFFSET p1   ; 获取过程 p1 的偏移地址，存入 AX
    MOV ADD1, AX        ; 将 AX 内容送入数据段内的 ADD1 处
    CALL ADD1           ; 转移至 ADD1 中存放的偏移地址处
    MOV BX, OFFSET ADD1 ; 获取数据 ADD1 的偏移地址，存入 BX
    CALL [BX]           ; 转移地址的偏移地址位于数据段中, 通过 BX 间接寻址获取

对于 `CALL ADD1` 指令，当 `ADD1` 是数据段中的一个地址而不是一个过程名/标号时，获取转移地址的方式是间接的，而不是直接的。它先从数据段 `ADD1` 确定的偏移地址中取出要转移去执行的地方的偏移值，然后再转移到代码段的此地址中。所以，当 `ADD1` 为变量名, `p1` 为过程名时，如下两条指令的差别是很大的:

    CALL p1
    CALL ADD1

前者是段 (CS) 内直接转移，后者是段内间接转移，其转移地址存放在数据段的 ADD1 处。

如果假设 `p1` 在代码段内的偏移值为 `000AH`, `ADD1` 在数据段内的偏移值为 `000AH`, 则上述两条指令在 DEBUG 下变为:

    CALL 000A   ; 直接转移至代码段 00A 处
    CALL [000A] ; 转移至代码段某处, 其偏移地址位于数据段的 00A 处

对于 `CALL BX` 指令，按照同样的道理，其转移至的代码段的偏移地址不是在 `BX` 中，而是在数据段的某个位置，这个位置由 `BX` 指出。`[BX]` 是普通的数据寄存器间接寻址，获取的数据单元的内容才是要转移至代码段内的偏移地址。所以如下两条指令虽然都是段内间接转移，但转移地址是不一样的:

    CALL BX     ; 转移到的偏移地址位于 BX 中
    CALL [BX]   ; 转移到的偏移地址在数据段某单元中, 此单元通过 BX 间接寻址得到

### 段间直接寻址

与段内直接寻址不同的是，段间直接寻址在指令中给出了要转移至（由 `JMP` 和 `CALL` 完成）的地址的代码段和偏移值内容。例如，如果 `p2` 为由 `FAR` 属性定义的过程，则如下指令为段间直接转移:

    CALL    FAR PTR p2

要转移至的标号或过程名必须具备 `FAR` 属性。

### 段间间接寻址

类似于段内间接寻址，但间接寻址时不能将要转移至的地址直接放入寄存器，而必须放入内存单元中，且是一个**双字**。格式如下:

    JMP     DWORD PTR [BX+INTERS]

其中 `[BX+INTERS]` 为数据的寄存器相对寻址方式，`DWORD PTR` 后可以是除立即寻址和寄存器寻址以外（也就是内存寻址）的任何一种方式。

内存单元中的转移地址是一个双字，低位在前高位在后。转移后，低位字变成 `IP`，高位字变成 `CS`。

