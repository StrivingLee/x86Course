# 指令格式与寻址方式

## 指令格式

Intel 8086/8088 基本指令格式:

    op dst, src  ; 由 "源" 至 "目的", 结果在目的操作数中

指令可以有 2 个, 1 个或 0 个操作数:

- `op op2, op1`
- `op op1`
- `op`

指令编码由 1-7 个字节组成，为变长编码。编码要素: 

- 操作码字节
- 寻址方式字节
- 段超越字节
- 操作数

## 寻址方式

<!-- 与数据有关: 

- 立即寻址
- 寄存器寻址
- 直接寻址
- 寄存器间接寻址
- 寄存器相对寻址
- 基址变址寻址

与转移/调用指令有关:

- 段内直接寻址
- 段内间接寻址
- 段间直接寻址
- 段间间接寻址

与 IO 有关:

- 直接 I/O 端口寻址
- 寄存器 DX 间接寻址 -->

### 与数据有关 (6 种)

(目的, 源) 操作数可以来自:

- 寄存器: 8 个通用寄存器, 4 个段寄存器, 1 个标志寄存器
- 立即数: 指令本身给出的立即数 (常量)
- 内存单元: 直接寻址/间接寻址
- 定义操作数: 
  - `EQU`: 常量
  - `DB`: 字节
  - `DW`: 字
  - `DD`: 双字

寻址方式:

- 立即寻址: 指令操作数包含在指令中，为一个常量或常数
- 寄存器寻址: 指令操作数为 CPU 的寄存器
- 直接寻址: 操作数偏移地址 `EA` 在指令中给出，如**变量名**
- 寄存器间接寻址: 操作数地址 `EA` 位于**间指**寄存器 (`BX`, `BP`, `SI`, `DI`) 中
- 寄存器相对寻址: 操作数地址 `EA` 由间指寄存器 + 8 位或 16 位的常量组成
- 基址变址寻址: 操作数地址 `EA` 为一个基址寄存器和一个变址寄存器之和

掌握和理解寻址要点:

1. 寄存器的使用规则
2. 类型匹配
3. 数据通路
4. 操作的是"内容"还是"地址"(指针)

#### 立即寻址

指令所需操作数直接包含在指令代码中，可以是一个**常量** (由 `EQU` 定义) 或者一个**常数**，成为**立即数**。

立即数可以是 8 位或 16 位，需要看与之对应的另一个操作数的类型（二者需要匹配）

    VALUE EQU 512       ; 定义一个常量, 名称为 VALUE, 值为 512
    MOV AL, 05H         ; AL = 05H
    MOV AL, 00000101b   ; AL = 05H, b 表示二进制
    MOV AX, 512         ; AX = 0200H (512 的十六进制)
    MOV AX, 512         ; AX = 0200H (VALUE 是常量，值是 512)

<font color="red">错误示例</font>:

    MOV AL, 100H        ; 100H 超出了 1 字节的范围
    MOV BL, VALUE       ; VALUE = 512, 超出了 1 字节的范围
    MOV AX, 10000H      ; 10000H 超出了 16 位 (一个字) 的范围

#### 寄存器寻址

指令中所需的操作数是 CPU 的某个寄存器，取操作数完全在 CPU 内部进行，不需要访存。

- 对于 8 位操作数，寄存器可以是 `AH`, `AL`, `BH`, `BL`, `CH`, `CL`, `DH`, `DL` 中的一个。
- 对于 16 位操作数，寄存器可以是 `AX`, `BX`, `CX`, `DX`, `SP`, `BP`, `SI`, `DI` 及 `CS`, `DS`, `SS`, `ES` 的任何一个（没有 `IP`）

寄存器寻址方式示例:

    MOV AX, BX      ; 源操作数和目的操作数都是寄存器寻址
    MOV AX, 1234H   ; 目的操作数是寄存器寻址
    ADD X, AX       ; 目的操作数是寄存器寻址
    PUSH DS         ; 源操作数是寄存器寻址

<!-- ADD X, AX 这条指令, X 是什么? -->

当使用 `CS`, `DS`, `SS`, `ES` 段寄存器时，必须遵循数据通路要求。

操作数中的寄存器可能是隐含的寄存器（没有明确出现在指令的源或目的操作数中），例如:

    PUSHF           ; PSW (标志寄存器) 作为源操作数，是寄存器寻址方式
    STD             ; 设置 DF = 1, 目的操作数是寄存器寻址方式

