# X86 第一次实验要点

## 编译和链接

```
MASM.EXE TTTT.ASM
LINK.EXE TTTT.OBJ
```

其中，编译时可选生成 `TTTT.LST` (机器码和汇编指令对照)，链接时可选生成 `TTTT.MAP` (内存段布局)。

## Debug

对内存的寻址方式: `寄存器:偏移量`, 例如 `DS:0300`

`r`: 查看寄存器
`d`: 查内存单元
`u`: 看反汇编程序

`e`: 改内存单元
`r`: 改寄存器
  - `r IP`: 改执行点
`a`: 改汇编指令

`t`: 单步执行
`p`: 单步 over
`g`: 执行到某个指令

`q`: 退出

## 第三题

(1) 修改要排序的表，合适位置放入字 `XXYY`, 其中 `XX` 为小班号, `YY` 为学号.

小班号取 `14H`, 学号取 `54H`

> **注意**:
> 
> 一开始 `DATA` 会位于 `DS:0300` 处，这是因为 `DS` 寄存器还未被初始化。在前面几条指令中，`DS` 被初始化为 `DATA` 的偏移值，所以当单步执行到排序开始前时，数据已经位于 `DS:0000`。
>
> `DATA` 的偏移值可以通过 `TTTT.MAP` 查看。
> 
> 整个数据区先有一个长度为 `100H` 个字（也就是 `200H` 个字节）的栈，然后是 `DATA`
>
> `DS` 寄存器一开始是 `075A`, 经过前面的初始化指令后，`DS` 变成了 `078A`, 而 `SS` 变成了 `076A`

放入 `DS:0004-DS:0005`:

```
-e DS:0004
078A:0004  2C.54
// 学号末两位

-e DS:0005
078A:0005  01.14
// 班号末两位
```

（上面这个位置）

(2) 修改 `JBE` 为 `JAE`

`JBE` 指令位于 `CS:0051`

改成 `JAE`:

```
-a CS:0051
0790:0051 JAE 005B
```

(3) 单步执行到排序前

一直按 `t` 直到 `START1` 或 `LP1`，也就是 `CS:0040`

查看数据区

执行到排序后，也就是 `MOV DX, OFFSET MY_NAME` 处

```
-g CS:0067
```

## 选做题

`TTTT.ASM` 中，`CS` 为 `0790`, `DS` 在正确置位后为 `078A`

(1) 将 `ADD1` 修改为长度为 32 位的班号学号水印

根据 `TTTT.LST` 查看到 `ADD1` 的偏移在 `004A`

水印: `18375354H`, 注意按字节小端序: `54 53 37 18`

```
-e DS:004A
078A:004A  00.54 30.53 00.37 20.18
```

(2) 改 `CS:IP` 至 `JMP DWORD PTR ADD1`, 截取单步执行此命令后的屏幕，解读 `CS:IP` 的值及含义。

该指令在 `TTTT.ASM` 的第 40 行，`0790:002C` 地址处。（阅读 `TTTT.LST`）

```
- r IP
IP 000D
:002C
```

按 `r` 观察当前指令的变化，然后按 `t` 执行。再按 `r` 观察 `CS` 和 `IP` 寄存器的值。

(3) 改 `CS:IP` 至 `CALL DWORD PTR ADD1`, 截取单步执行此命令后的屏幕，显示堆栈段的栈顶处，截取堆栈栈顶数据区屏幕，解读栈顶值及含义。

在 `TTTT.LST` 找到该指令位于 `0790:0036` 地址。

先改 `CS:IP`:

```
-r CS
:0790
-r IP
:0036
```

按 `r` 观察当前指令的变化，按 `t` 单步执行。再按 `r` 查看 `SP` 的值：`SP=01FC`，再查看内存:

```
-d SS:01FC
```

可以查看到栈顶的首个双字为 `0790003AH`, 刚好和 `CALL` 指令的下一条指令的地址 `0790:003A` 相同。
